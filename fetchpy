#!/usr/bin/env python3
#
#       Ferit Yiğit BALABAN <fyb@duck.com>, 2022
#
#       fetchpy, fetch script alternative to neofetch
import os
import subprocess as sp
from rich.console import Console
from rich.traceback import install
install(show_locals=True)


def coloring(text):
    color1 = '#' + '785BAF'
    color2 = '#' + 'DF73AA'
    color3 = '#' + 'B6D871'
    color4 = '#' + 'F1E7C2'
    color5 = '#' + '77B2CC'
    frame = color2
    info = color3
    title = color5
    color_dictionary = {
        '╭': frame,
        '╰': frame,
        '╯': frame,
        '─': frame,
        '╮': frame,
        '┤': frame,
        '│': frame,
        '├': frame,
        'DIST': info,
        'KERN': info,
        'SHEL': info,
        'TERM': info,
        'PACK': info,
        'CPU': info,
        'iGPU': info,
        'dGPU': info,
        'MEM': info,
        'UPT': info,
        'ferit@navi': title,
        'Hardware': title,
        '-@\n': color1,
        '.##@': color1,
        '.####@': color1,
        '@#####@': color2,
        '.**######@': color2,
        '.##@o@#####@': color2,
        '.############@': color3,
        '.##############@': color3,
        '@######@**%######@': color3,
        '@######`': color4,
        '%#####o': color4,
        '@######@': color4,
        '######%': color4,
        '-@#######h': color4,
        '######@.`': color4,
        '.#####h**``': color5,
        '`**%@####@': color5,
        '@H@*`': color5,
        '*`': color5,
        '`*%#@': color5,
        '`*': color5,
    }
    c = Console()
    iterator = 0
    while iterator < len(text):
        character = text[iterator]
        peekable = iterator < len(text) - 1
        peek = text[iterator + 1] if peekable else ' '

        if character == ' ':
            if peekable and peek != ' ' and not color_dictionary.__contains__(peek):
                print(' ', end='')
                word, jump_to = read_until_space(text, start_at=iterator + 1)
                if color_dictionary.__contains__(word):
                    c.print(word, style=color_dictionary[word], end='')
                else:
                    print(word, end='')
                iterator = jump_to
            print(' ', end='')
        elif color_dictionary.__contains__(character):
            c.print(character, style=color_dictionary[character], end='')
        else:
            print(character, end='')
        iterator += 1
    print('')


def read_until_space(text, start_at):
    buffer = ''
    iterator = start_at
    while text[iterator] != ' ':
        buffer += text[iterator]
        iterator += 1
    next_space_at = iterator
    return buffer, next_space_at


def main():
    padding_count = 29

    distro_name = 'Arch GNU/Linux x86_64'
    distro_name = distro_name.ljust(padding_count, ' ')

    kernel_version = str(os.uname().release)
    kernel_version = kernel_version.ljust(padding_count, ' ')

    shell_name = 'fish'
    query_pacman = sp.Popen(['pacman', '-Q'], stdout=sp.PIPE)
    grep_paclist = sp.Popen(['grep', f'{shell_name}'], stdin=query_pacman.stdout, stdout=sp.PIPE)
    query_pacman.stdout.close()
    shell_name, err = grep_paclist.communicate()
    shell_name = str(shell_name).removeprefix('b\'').removesuffix('\\n\'').ljust(padding_count, ' ')

    terminal_name = 'kitty'
    terminal_name = terminal_name.ljust(padding_count, ' ')

    query_pacman = sp.Popen(['pacman', '-Q'], stdout=sp.PIPE)
    count_output = sp.Popen(['wc', '-l'], stdin=query_pacman.stdout, stdout=sp.PIPE)
    output, err = count_output.communicate()
    package_count = str(output).removeprefix('b\'').removesuffix('\\n\'').ljust(padding_count, ' ')

    total_memory, used_memory, free_memory, d1, d2, d3 = map(int, os.popen('free -m').readlines()[1].split()[1:])
    mem_percentage = round((used_memory / total_memory) * 100, 2)
    used_memory = round((used_memory / 1024), 1)
    total_memory = round((total_memory / 1024), 1)
    memory_usage = f'{used_memory} GiB / {total_memory} GiB ({mem_percentage}%)'.ljust(padding_count, ' ')

    with open('/proc/uptime', 'r') as f:
        uptime_seconds = float(f.readline().split()[0])
        f.close()
    if uptime_seconds < 60:
        uptime = str(uptime_seconds).split('.')[0] + ' seconds'
    elif uptime_seconds < 3600:
        number = str(uptime_seconds / 60).split('.')[0]
        uptime = f'{number} minute' if number == '1' else f'{number} minutes'
    else:
        number = str(uptime_seconds / 3600).split('.')[0]
        uptime = f'{number} hour' if number == '1' else f'{number} hours'
    uptime = uptime.ljust(padding_count, ' ')

    txt = f'''
                -@
               .##@                ╭──────────── ferit@navi ────────────╮
              .####@               │ DIST  {distro_name}│
              @#####@              │ KERN  {kernel_version}│
            .**######@             │ SHEL  {shell_name}│
           .##@o@#####@            │ TERM  {terminal_name}│
          .############@           │ PACK  {package_count}│
         .##############@          ├───────────── Hardware ─────────────┤
        @######@**%######@         │ CPU   AMD Ryzen 7 5800H (16 Cores) │
       @######`     %#####o        │ iGPU  AMD Radeon™ Graphics (2 GHz) │
      @######@       ######%       │ dGPU  NVIDIA GeForce RTX 3050 Ti   │
    -@#######h       ######@.`     │ MEM   {memory_usage}│
   .#####h**``       `**%@####@    │ UPT   {uptime}│
  @H@*`                    `*%#@   ╰────────────────────────────────────╯
 *`                            `* 
'''
    coloring(txt)


if __name__ == '__main__':
    main()
